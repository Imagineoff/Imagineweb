<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Roomla — Pre-Alpha (Silent Studio)</title>
<meta name="description" content="Pre-alpha web horror prototype — Silent Studio" />
<style>
/* =========================
   STYLES (komplet single file)
   ========================= */
:root{
  --bg:#040406;
  --card:#0b0b0d;
  --muted:#9aa;
  --accent:#9bf;
  --danger:#ff5555;
  --calm:#6fffb0;
  --glass: rgba(255,255,255,0.02);
  --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", "Courier New", monospace;
}

/* base */
*{box-sizing:border-box}
html,body{height:100%; margin:0; background:linear-gradient(180deg,#030305 0%, #050308 100%); color:#eaeaea; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; -webkit-font-smoothing:antialiased}
a{color:var(--accent)}
.container{max-width:1200px;margin:20px auto;padding:18px}

/* header */
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
.title{font-family: 'Orbitron', ui-monospace, monospace; letter-spacing:2px; font-size:1.25rem}
.sub{color:var(--muted); font-size:0.85rem}

/* room layout */
.room{display:grid; grid-template-columns: 1fr 340px; gap:18px; margin-top:16px}
.scene{background: linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.005)); border-radius:10px; padding:18px; border:1px solid rgba(255,255,255,0.03); position:relative; min-height:520px; overflow:hidden}
.panel{background:transparent;padding:12px;border-radius:8px}

/* visual room */
.room-visual{position:relative; height:100%; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:10px}
.lamp{position:absolute; left:42px; top:28px; width:84px; height:120px; display:flex; align-items:center; justify-content:center; flex-direction:column; pointer-events:none;}
.lamp .bulb{width:40px;height:40px;border-radius:50%;background:radial-gradient(circle at 30% 30%, #fff6, #fffa00 20%, #ff9 30%, transparent 55%); box-shadow: 0 0 30px rgba(255,200,80,0.12); transform: rotate(-6deg)}
.lamp .stand{width:8px;height:60px;background:linear-gradient(#222,#111);margin-top:6px}

.desk {width:88%; margin-top:86px; display:flex; gap:18px; align-items:flex-start; justify-content:center}
.pc-wrap{width:420px; display:flex; flex-direction:column; align-items:center; gap:10px}
.pc-screen{width:420px; height:220px; background:#03050a; border-radius:8px; border:1px solid rgba(255,255,255,0.03); display:flex; align-items:center; justify-content:center; font-family:var(--font-mono); color:#9ff; font-size:14px; padding:12px; text-align:center; position:relative}
.pc-ui{display:flex;gap:8px}
.controls{display:flex;gap:8px; margin-top:8px}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.06); padding:8px 12px;border-radius:8px;color:var(--accent);cursor:pointer}
.btn.ghost{opacity:.8}
.btn.danger{border-color:rgba(255,90,90,0.25); color:var(--danger)}
.pills{display:flex; gap:8px; align-items:center; justify-content:center}
.pill{width:36px;height:18px;border-radius:6px;background:linear-gradient(180deg,#ffb3b3,#ff4f4f);box-shadow:0 6px 18px rgba(255,60,60,0.06);display:inline-flex;align-items:center;justify-content:center;color:#111;font-weight:700;cursor:pointer;border:1px solid rgba(255,255,255,0.04)}
.pill.empty{opacity:0.18; filter:grayscale(0.8); background:linear-gradient(180deg,#333,#111);color:#777}

/* right panel */
.right {display:flex;flex-direction:column; gap:10px}
.info{font-size:13px;color:var(--muted)}
.metrics{display:flex;flex-direction:column;gap:8px; margin-top:6px}
.metric{background:linear-gradient(180deg, rgba(255,255,255,0.01),transparent); padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.02); font-size:13px}
.metric .label{color:var(--muted); font-size:12px}
.metric .value{font-weight:700; font-size:16px;color:#fff; margin-top:4px}

/* overlay / task modal */
.overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:999; background:rgba(0,0,0,0.7)}
.taskbox{width:min(900px,96%); background:#060708; border-radius:12px; padding:16px; border:1px solid rgba(255,255,255,0.03); box-shadow:0 20px 80px rgba(0,0,0,0.7)}
.task-header{display:flex; justify-content:space-between; align-items:center; gap:12px}
.task-body{margin-top:12px}

/* small UI bits for tasks */
.grid{display:grid;gap:8px}
.grid.cols-3{grid-template-columns:repeat(3,1fr)}
.card{background:#071017;border-radius:8px;padding:12px;border:1px solid rgba(255,255,255,0.02); text-align:center; color:#cfe}
.card.clickable{cursor:pointer}
.memory-card{height:64px; display:flex; align-items:center; justify-content:center; font-weight:800; font-size:1.1rem; user-select:none;}

/* dot-eater canvas */
#eatCanvas{width:100%; height:260px; background:#001217; border-radius:8px; display:block; margin:8px 0; border:1px solid rgba(255,255,255,0.02)}

/* typing */
.codeBox{background:#021212;border-radius:8px;padding:12px;border:1px solid rgba(0,255,255,0.03); font-family:var(--font-mono); color:#9ff; white-space:pre-wrap; max-height:220px; overflow:auto}

/* panic overlay (red) */
.panic-overlay{position:fixed; inset:0; background:rgba(255,0,0,0); pointer-events:none; transition: background 0.25s linear; z-index:1000}
.panic-red{background:rgba(180,0,0,0.48); pointer-events:auto}

/* jumpscare full-screen */
.jumpscare{position:fixed; inset:0; background:#000; display:none; align-items:center; justify-content:center; z-index:2000; flex-direction:column}
.jumpscare.show{display:flex}
.jumpscare .face{width:60vmin; max-width:720px; height:60vmin; max-height:720px; background:
  radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), transparent 10%),
  linear-gradient(180deg,#220002,#000);
  border-radius:8px; display:flex;align-items:center;justify-content:center;color:#fff; font-size:6vmin; font-family:var(--font-mono);
  transform:scale(1); transition:transform .12s ease;}
.jumpscare.flash{animation:flash 0.12s linear 0s 6}
@keyframes flash {
  0%{filter:brightness(1)}
  50%{filter:brightness(30)}
  100%{filter:brightness(1)}
}

/* footer */
.footer{margin-top:12px;text-align:center;color:var(--muted);font-size:13px}

/* responsive */
@media (max-width:960px){
  .room{grid-template-columns:1fr; padding-bottom:60px}
  .lamp{left:14px}
  .pc-wrap{width:100%}
}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div>
        <div class="title">ROOMLA • Silent Studio (pre-alpha)</div>
        <div class="sub">Prototype — test gameplay, tasks & panic mechanics</div>
      </div>
      <div class="sub">Playtime target: ≤ 10 minutes</div>
    </div>

    <div class="room">
      <!-- LEFT: visual scene -->
      <div class="scene room-visual" id="scene">
        <div class="lamp" aria-hidden="true">
          <div class="bulb" id="lampBulb"></div>
          <div class="stand"></div>
        </div>

        <div class="desk">
          <div class="pc-wrap">
            <div class="pc-screen" id="pcScreen" aria-live="polite">Click the <strong>PC</strong> to start a task.<br><span style="font-size:12px;color:var(--muted)">Double-click or press <kbd>Enter</kbd> to quick open.</span></div>
            <div class="controls" style="justify-content:center;margin-top:6px">
              <button class="btn" id="openPc" title="Open PC">Open PC</button>
              <button class="btn ghost" id="powerBtn">POWER OFF</button>
              <button class="btn" id="takePillBtn" title="Take pill (P)">Take Pill (P)</button>
            </div>
          </div>

          <div style="width:320px; display:flex; justify-content:center; margin-top:18px">
            <div class="pills" id="pillsContainer" aria-hidden="false">
              <div class="pill" data-idx="0">5</div>
              <div class="pill" data-idx="1">4</div>
              <div class="pill" data-idx="2">3</div>
              <div class="pill" data-idx="3">2</div>
              <div class="pill" data-idx="4">1</div>
            </div>
          </div>
        </div>

        <div id="floorNote" style="position:absolute; left:14px; bottom:12px; color:var(--muted); font-size:12px">
          A small girl follows you. You don't remember.
        </div>
      </div>

      <!-- RIGHT: info / metrics -->
      <div class="scene right">
        <div class="panel">
          <div class="info">You are in a small room with an old PC. Complete tasks on the computer while managing your panic. Use pills (5) to calm breathing. If panic reaches maximum — red screen and jump scare.</div>
        </div>

        <div class="metrics">
          <div class="metric">
            <div class="label">Game Timer</div>
            <div class="value" id="gameTimer">10:00</div>
          </div>
          <div class="metric">
            <div class="label">Active Task</div>
            <div class="value" id="activeTask">None</div>
          </div>
          <div class="metric">
            <div class="label">Pills left</div>
            <div class="value" id="pillValue">5</div>
          </div>
          <div class="metric">
            <div class="label">Panic</div>
            <div class="value" id="panicValue">0%</div>
          </div>
          <div class="metric">
            <div class="label">Progress (tasks completed)</div>
            <div class="value" id="progressValue">0 / 3</div>
          </div>
        </div>

        <div class="panel" style="margin-top:8px">
          <div class="info" style="margin-bottom:8px"><strong>Controls</strong></div>
          <div class="info">Open PC: click button / double-click screen / Enter<br>Take pill: P key / button<br>Power off: click POWER (will abort active task)<br>Close task: Esc or Abort inside task UI</div>
        </div>

        <div class="panel" style="margin-top:auto">
          <div class="info">Prototype notes: this build is meant for testing core flow. Tasks are simplified and intentionally childlike to create tension.</div>
        </div>
      </div>
    </div>

    <div class="footer">Prototype build — Silent Studio. Report bugs and feedback.</div>
  </div>

  <!-- Overlay / task modal -->
  <div class="overlay" id="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="taskbox" role="document">
      <div class="task-header">
        <div>
          <div style="font-weight:800;font-family:var(--font-mono)" id="taskTitle">Task</div>
          <div style="font-size:12px;color:var(--muted)" id="taskSub">Do the small game — don't get caught.</div>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <div style="font-size:12px;color:var(--muted)">Task timer:</div>
          <div style="font-weight:700" id="taskTimer">--</div>
          <button class="btn ghost" id="abortTaskBtn">Abort (fail)</button>
        </div>
      </div>

      <div class="task-body" id="taskBody">
        <!-- dynamic -->
        <div style="display:flex;gap:12px;align-items:center;justify-content:center;padding:18px">
          <div style="color:var(--muted)">Choose a task to begin:</div>
        </div>
        <div class="grid cols-3" style="margin-top:6px">
          <div class="card clickable" data-task="memory" id="taskMemory">Memory (pairs)</div>
          <div class="card clickable" data-task="typing" id="taskTyping">Type it exactly</div>
          <div class="card clickable" data-task="eat" id="taskEat">Dot Snack</div>
          <div class="card clickable" data-task="pac" id="taskPac">Pac-like (simple)</div>
          <div class="card clickable" data-task="repair" id="taskRepair">Repair wires</div>
        </div>
      </div>
    </div>
  </div>

  <!-- panic red overlay -->
  <div class="panic-overlay" id="panicOverlay" aria-hidden="true"></div>

  <!-- jumpscare -->
  <div class="jumpscare" id="jumpscare" aria-hidden="true">
    <div class="face" id="jumpscareFace">...</div>
  </div>

<script>
/* =========================
   SCRIPT: kompletní engine pre-alpha
   ========================= */

/* ---------- GAME STATE ---------- */
const MAX_PILLS = 5;
let pills = MAX_PILLS;
let panic = 0; // 0-100 %
let progressCompleted = 0;
const PROGRESS_TO_WIN = 3;
let activeTask = null; // identifier
let taskTimerInterval = null;
let taskRemaining = 0;
let overlayOpen = false;

let audioCtx = null;
let breathOsc = null;
let breathGain = null;
let breathingRunning = false;
let breathEventTimer = null;

const GAME_DURATION_MS = 10 * 60 * 1000; // 10 minutes
let gameStart = Date.now();
let gameTimerInterval = null;

/* ---------- DOM ---------- */
const pcScreen = document.getElementById('pcScreen');
const openPc = document.getElementById('openPc');
const powerBtn = document.getElementById('powerBtn');
const takePillBtn = document.getElementById('takePillBtn');
const pillsContainer = document.getElementById('pillsContainer');
const pillValue = document.getElementById('pillValue');
const panicValue = document.getElementById('panicValue');
const progressValue = document.getElementById('progressValue');
const gameTimerEl = document.getElementById('gameTimer');
const activeTaskEl = document.getElementById('activeTask');

const overlay = document.getElementById('overlay');
const taskTitle = document.getElementById('taskTitle');
const taskSub = document.getElementById('taskSub');
const taskBody = document.getElementById('taskBody');
const abortTaskBtn = document.getElementById('abortTaskBtn');
const taskTimerEl = document.getElementById('taskTimer');

const panicOverlay = document.getElementById('panicOverlay');
const jumpscareEl = document.getElementById('jumpscare');
const jumpscareFace = document.getElementById('jumpscareFace');

/* ---------- HELPERS: AUDIO (WebAudio synthesized) ---------- */
function ensureAudio(){
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playBeep(freq=440,dur=0.08,vol=0.04,type='sine'){
  ensureAudio();
  const g = audioCtx.createGain(); g.gain.value = vol; g.connect(audioCtx.destination);
  const o = audioCtx.createOscillator(); o.type = type; o.frequency.value = freq;
  o.connect(g); o.start();
  o.stop(audioCtx.currentTime + dur);
}

function startBreathingLoop(){
  if (breathingRunning) return;
  ensureAudio();
  breathingRunning = true;
  // breathing sound is generated on events; we keep an ambient low oscillator to make atmosphere
  breathOsc = audioCtx.createOscillator();
  breathOsc.type = 'sine';
  breathOsc.frequency.value = 40;
  breathGain = audioCtx.createGain();
  breathGain.gain.value = 0.0;
  breathOsc.connect(breathGain); breathGain.connect(audioCtx.destination);
  breathOsc.start();
  scheduleBreathEvent();
}

/* Schedule breath event depending on panic and time since last pill.
   Higher panic -> more frequent breath events.
*/
function scheduleBreathEvent(){
  if (breathEventTimer) { clearTimeout(breathEventTimer); breathEventTimer = null; }
  // interval between breath events: 6s -> 1.2s depending on panic
  const min = 1200;
  const max = 8000;
  const interval = Math.round(max - (panic/100) * (max - min));
  // add small randomness
  const jitter = Math.floor(Math.random() * 800) - 400;
  const next = Math.max(min, interval + jitter);
  breathEventTimer = setTimeout(()=> { triggerBreath(); scheduleBreathEvent(); }, next);
}

/* Trigger a single breath sequence (alert to user). If player doesn't react, we cause penalty. */
let breathActive = false;
function triggerBreath(){
  // if overlay open and activeTask -> show breathing alert and start timer to force power off
  // escalate if panic high
  if (breathActive) return;
  breathActive = true;
  // ramp the breath gain for a short inhale
  if (!audioCtx) startBreathingLoop();
  const g = audioCtx.createGain(); g.gain.value = 0.0; g.connect(audioCtx.destination);
  const o = audioCtx.createOscillator(); o.type = 'sine'; o.frequency.value = 120;
  o.connect(g); o.start();
  // ramp up
  g.gain.linearRampToValueAtTime(0.12 + panic/600, audioCtx.currentTime + 0.55);
  // hold then down
  setTimeout(()=> {
    g.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.5);
    o.stop(audioCtx.currentTime + 0.6);
  }, 700);

  // visual hint: briefly pulse panic overlay
  panicOverlay.classList.add('panicPulse');
  panicOverlay.style.transition = 'background 0.12s linear';
  panicOverlay.style.background = 'rgba(0,0,0,0.0)';
  setTimeout(()=>{ if(!jumpscareEl.classList.contains('show')) panicOverlay.style.background = 'rgba(0,0,0,0.0)'; }, 200);

  // if active task -> require quick power off
  if (activeTask){
    // grace period depends on panic
    const baseGrace = 1700;
    const grace = Math.max(600, baseGrace - panic*10);
    let handled = false;
    // bind one-time event
    const onPower = ()=>{
      handled = true;
      // abort active task gracefully (counts as fail)
      appendScreenText('Power cut — active task aborted.');
      finishActiveTask(false);
    };
    powerBtn.addEventListener('click', onPower, {once:true});

    setTimeout(()=>{
      if (!handled){
        // failed to power off in time -> penalty
        appendScreenText('You froze... something gets closer.');
        // small penalty: consume a pill if available, else increase panic by a chunk
        if (pills > 0){
          pills = Math.max(0, pills - 1);
          updatePillsUI();
          appendScreenText('You dropped a pill in panic (lost 1).');
        } else {
          // if no pills -> big panic spike
          increasePanic(18);
        }
        // also fail active task
        if (activeTask) finishActiveTask(false);
      }
      breathActive = false;
    }, grace + 30);
  } else {
    // if no active task, just show breathing sound and smaller effect
    setTimeout(()=> breathActive = false, 900);
  }
}

/* ---------- UI update helpers ---------- */
function appendScreenText(txt){
  pcScreen.innerHTML = `<div style="font-size:14px">${escapeHtml(txt)}</div>`;
}
function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;'); }

function updatePanicUI(){
  panic = Math.max(0, Math.min(100, panic));
  panicValue.textContent = `${panic}%`;
  // overlay strength corresponds to panic %
  const alpha = Math.min(0.55, panic/200);
  panicOverlay.style.background = `rgba(180,0,0,${alpha})`;
  if (panic >= 100) {
    triggerJumpscare();
  }
}

function increasePanic(amount){
  panic = Math.min(100, panic + amount);
  updatePanicUI();
}

function decreasePanic(amount){
  panic = Math.max(0, panic - amount);
  updatePanicUI();
}

function updatePillsUI(){
  pillValue.textContent = String(pills);
  const pillEls = pillsContainer.querySelectorAll('.pill');
  pillEls.forEach((el, idx)=>{
    const remaining = MAX_PILLS - idx;
    // visually map: first element shows '5', last shows '1' per initial markup
    // we mark empty based on pills count
    const showIndex = idx; // 0..4
    if (idx >= (MAX_PILLS - pills)) {
      el.classList.remove('empty');
    } else {
      el.classList.add('empty');
    }
  });
}

function updateProgressUI(){
  progressValue.textContent = `${progressCompleted} / ${PROGRESS_TO_WIN}`;
}

/* ---------- GAME TIMER ---------- */
function startGameTimer(){
  gameStart = Date.now();
  updateGameTimer();
  if (gameTimerInterval) clearInterval(gameTimerInterval);
  gameTimerInterval = setInterval(updateGameTimer, 700);
}
function updateGameTimer(){
  const rem = Math.max(0, GAME_DURATION_MS - (Date.now() - gameStart));
  const mm = Math.floor(rem / 60000);
  const ss = Math.floor((rem % 60000)/1000).toString().padStart(2,'0');
  gameTimerEl.textContent = `${mm}:${ss}`;
  if (rem <= 0){
    clearInterval(gameTimerInterval);
    endGame(false, 'Time ran out.');
  }
}

/* ---------- TASK FLOW ---------- */
function openOverlay(){
  overlay.style.display = 'flex';
  overlay.setAttribute('aria-hidden','false');
  overlayOpen = true;
  taskTitle.textContent = 'Choose a task';
  taskSub.textContent = 'Childlike mini-games — complete enough to win.';
  taskBody.querySelectorAll('.card.clickable').forEach(el=>{
    el.onclick = () => { startTask(el.dataset.task); };
  });
}
function closeOverlay(){
  overlay.style.display = 'none';
  overlay.setAttribute('aria-hidden','true');
  overlayOpen = false;
}

/* Start a task type (init UI and logic) */
function startTask(kind){
  if (activeTask) { alert('Task already active.'); return; }
  activeTask = kind;
  activeTaskEl.textContent = kind;
  openTaskUI(kind);
}

/* finish active task; success boolean matters */
function finishActiveTask(success){
  if (!activeTask) return;
  if (taskTimerInterval) { clearInterval(taskTimerInterval); taskTimerInterval = null; }
  // show result
  if (success){
    appendScreenText('Task success.');
    progressCompleted++;
    updateProgressUI();
    decreasePanic(8 + Math.floor(Math.random()*6));
    playBeep(1000,0.08,0.06,'sine');
    if (progressCompleted >= PROGRESS_TO_WIN){
      endGame(true, 'You forced memory open.');
    }
  } else {
    appendScreenText('Task failed.');
    increasePanic(10 + Math.floor(Math.random()*8));
    playBeep(160,0.24,0.06,'sine');
  }
  activeTask = null;
  activeTaskEl.textContent = 'None';
  // return to choose tasks
  setTimeout(()=> { renderTaskChoices(); }, 600);
}

/* Abort task by player (counts as fail) */
abortTaskBtn.addEventListener('click', ()=> {
  if (!activeTask) { closeOverlay(); return; }
  if (confirm('Abort task? This counts as a failure.')) {
    finishActiveTask(false);
  }
});

/* Power button behavior: toggles power and aborts active task if turning off */
let powerOn = true;
powerBtn.addEventListener('click', ()=>{
  powerOn = !powerOn;
  powerBtn.textContent = powerOn ? 'POWER OFF' : 'POWER ON';
  // quick sound
  playBeep(powerOn ? 660 : 220, 0.06, 0.05);
  if (!powerOn && activeTask){
    // abort active task immediately
    appendScreenText('Power cut by player — task aborted.');
    finishActiveTask(false);
  }
});

/* Take pill */
takePillBtn.addEventListener('click', takePillHandler);
document.addEventListener('keydown', (e)=> {
  if (e.key.toLowerCase() === 'p') takePillHandler();
  if (e.key === 'Enter' && !overlayOpen) openOverlay();
  if (e.key === 'Escape' && overlayOpen) {
    if (activeTask) {
      if (confirm('Exit task? This will fail it.')) finishActiveTask(false);
    } else closeOverlay();
  }
});

function takePillHandler(){
  if (pills <= 0) { appendScreenText('No pills left.'); playBeep(220,0.08,0.05,'sine'); return; }
  pills--;
  updatePillsUI();
  // calming effect: decrease panic and reschedule breathing
  decreasePanic(18);
  appendScreenText('You took a pill. The breathing calms a bit.');
  playBeep(1200, 0.07, 0.06, 'sine');
  // reset breath timing (schedule)
  scheduleBreathEvent();
}

/* ---------- TASK UIs ---------- */

/* render the initial choices (default) */
function renderTaskChoices(){
  taskBody.innerHTML = `
    <div style="display:flex;gap:12px;align-items:center;justify-content:center;padding:18px">
      <div style="color:var(--muted)">Choose a task to begin:</div>
    </div>
    <div class="grid cols-3" style="margin-top:6px">
      <div class="card clickable" data-task="memory">Memory (pairs)</div>
      <div class="card clickable" data-task="typing">Type it exactly</div>
      <div class="card clickable" data-task="eat">Dot Snack</div>
      <div class="card clickable" data-task="pac">Pac-like (simple)</div>
      <div class="card clickable" data-task="repair">Repair wires</div>
    </div>
  `;
  taskBody.querySelectorAll('.card.clickable').forEach(el=>{
    el.onclick = ()=> startTask(el.dataset.task);
  });
  taskTimerEl.textContent = '--';
  taskTitle.textContent = 'Choose a task';
  taskSub.textContent = 'Childlike mini-games — complete enough to win.';
}

/* opens overlay and renders choices */
openPc.addEventListener('click', ()=> {
  ensureAudio();
  startBreathingLoop();
  renderTaskChoices();
  openOverlay();
  appendScreenText('You open the PC. Choose a small task.');
});

/* open when double-click on main screen */
pcScreen.addEventListener('dblclick', ()=> openPc.click());

/* open an actual task UI based on kind */
function openTaskUI(kind){
  taskBody.innerHTML = ''; // clear
  taskTitle.textContent = kind.toUpperCase();
  taskSub.textContent = 'Complete the task — be quick.';
  activeTask = kind;
  // per-task durations and handlers
  let duration = 45; // seconds default
  if (kind === 'typing') duration = 75;
  if (kind === 'memory') duration = 60;
  if (kind === 'pac') duration = 55;
  if (kind === 'eat') duration = 45;
  if (kind === 'repair') duration = 50;

  // create countdown UI
  let timeLeft = duration;
  taskTimerEl.textContent = `${timeLeft}s`;
  if (taskTimerInterval) clearInterval(taskTimerInterval);
  taskTimerInterval = setInterval(()=> {
    timeLeft--;
    taskTimerEl.textContent = `${timeLeft}s`;
    if (timeLeft <= 0) {
      clearInterval(taskTimerInterval);
      taskTimerInterval = null;
      // fail
      if (activeTask) finishActiveTask(false);
    }
  }, 1000);

  // inject specific UI
  if (kind === 'memory') initMemoryTask(taskBody);
  if (kind === 'typing') initTypingTask(taskBody);
  if (kind === 'eat') initEatTask(taskBody);
  if (kind === 'pac') initPacTask(taskBody);
  if (kind === 'repair') initRepairTask(taskBody);
}

/* ---------- MEMORY TASK (3 pairs) ---------- */
function initMemoryTask(container){
  const pairs = ['★','♠','☾','◆','✦','●'].slice(0,3);
  const deck = [...pairs, ...pairs].sort(()=>Math.random()-0.5);
  const grid = document.createElement('div');
  grid.className = 'grid cols-3';
  deck.forEach((v,i)=>{
    const card = document.createElement('div');
    card.className = 'memory-card card clickable hidden';
    card.textContent = v;
    card.dataset.val = v;
    card.dataset.revealed = '0';
    card.style.background = '#071017';
    card.style.color = '#071017'; // hidden
    card.addEventListener('click', ()=> {
      if (card.dataset.revealed === '1') return;
      revealCard(card);
    });
    grid.appendChild(card);
  });
  container.appendChild(grid);
  let first = null, matches = 0;
  function revealCard(c){
    c.dataset.revealed = '1';
    c.style.color = '#fff';
    c.style.background = '#0d2328';
    if (!first){ first = c; return; }
    if (first.dataset.val === c.dataset.val){
      // match
      first.style.background = 'linear-gradient(90deg,#294 0%, #1aa 100%)';
      c.style.background = 'linear-gradient(90deg,#294 0%, #1aa 100%)';
      matches++;
      first = null;
      if (matches === pairs.length){
        // success
        setTimeout(()=> finishActiveTask(true), 400);
      }
    } else {
      // mismatch
      setTimeout(()=> {
        first.dataset.revealed = '0'; first.style.color = '#071017'; first.style.background = '#071017';
        c.dataset.revealed = '0'; c.style.color = '#071017'; c.style.background = '#071017';
        first = null;
      }, 650);
    }
  }
}

/* ---------- TYPING TASK ---------- */
function initTypingTask(container){
  const snippet = `function rememberNight() {
  // the soft breath
  let echo = "hush";
  return echo;
}`;
  const codeBox = document.createElement('div');
  codeBox.className = 'codeBox';
  codeBox.textContent = snippet.replace(/ /g, '\u00a0');
  const input = document.createElement('textarea');
  input.style.width = '100%';
  input.style.minHeight = '80px';
  input.style.marginTop = '8px';
  input.style.fontFamily = 'monospace';
  input.placeholder = 'Type the snippet exactly...';
  container.appendChild(codeBox);
  container.appendChild(input);
  input.focus();
  input.addEventListener('input', ()=>{
    // naive exact match (normalize line endings)
    if (input.value.replace(/\r\n/g,'\n') === snippet){
      finishActiveTask(true);
    }
  });
}

/* ---------- DOT-EATER (simple) ---------- */
function initEatTask(container){
  container.innerHTML = `<canvas id="eatCanvas" width="720" height="260"></canvas>
    <div style="font-size:12px;color:var(--muted);margin-top:6px">Use arrow keys to move. Collect all dots.</div>`;
  const canvas = container.querySelector('#eatCanvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  let px = 40, py = 40, pr = 10;
  const DOTS = 10;
  const dots = [];
  for (let i=0;i<DOTS;i++){
    dots.push({x:40+Math.random()*(w-80), y:40+Math.random()*(h-80), r:4, got:false});
  }
  let keys = {};
  function draw(){
    ctx.fillStyle = '#001217'; ctx.fillRect(0,0,w,h);
    // dots
    ctx.fillStyle = '#ffdd88';
    let remaining = 0;
    for (const d of dots){ if (!d.got){ ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.fill(); remaining++; } }
    // player
    ctx.fillStyle = '#9ff'; ctx.beginPath(); ctx.arc(px,py,pr,0,Math.PI*2); ctx.fill();
    // move
    if (keys.ArrowUp) py -= 2.6;
    if (keys.ArrowDown) py += 2.6;
    if (keys.ArrowLeft) px -= 2.6;
    if (keys.ArrowRight) px += 2.6;
    px = Math.max(pr, Math.min(w-pr, px)); py = Math.max(pr, Math.min(h-pr, py));
    // collision
    for (const d of dots){ if (!d.got){ const dx=px-d.x, dy=py-d.y; if (Math.hypot(dx,dy) < pr + d.r){ d.got=true; playBeep(900,0.04,0.04); } } }
    if (remaining === 0){ document.removeEventListener('keydown', kd); document.removeEventListener('keyup', ku); finishActiveTask(true); return; }
    else requestAnimationFrame(draw);
  }
  function kd(e){ keys[e.key]=true; }
  function ku(e){ keys[e.key]=false; }
  document.addEventListener('keydown', kd); document.addEventListener('keyup', ku);
  requestAnimationFrame(draw);
}

/* ---------- PAC-LIKE SIMPLE (very simplified) ---------- */
function initPacTask(container){
  container.innerHTML = `<canvas id="pacCanvas" width="720" height="260"></canvas>
    <div style="font-size:12px;color:var(--muted);margin-top:6px">Collect pellets. Avoid ghost (slow).</div>`;
  const canvas = container.querySelector('#pacCanvas');
  const ctx = canvas.getContext('2d');
  const w = canvas.width, h = canvas.height;
  const pellets = [];
  for (let x=40;x<w-40;x+=40){
    for (let y=40;y<h-40;y+=40){
      if (Math.random()<0.55) pellets.push({x,y,got:false});
    }
  }
  let player = {x:60,y:60,r:10};
  let ghost = {x:w-60,y:h-60,r:12,dir:0};
  let keys = {};
  function draw(){
    ctx.fillStyle = '#001217'; ctx.fillRect(0,0,w,h);
    // draw pellets
    ctx.fillStyle = '#ffdd88';
    let left = 0;
    for (const p of pellets){ if (!p.got){ ctx.beginPath(); ctx.arc(p.x,p.y,4,0,Math.PI*2); ctx.fill(); left++; } }
    // draw ghost
    ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.arc(ghost.x,ghost.y,ghost.r,0,Math.PI*2); ctx.fill();
    // draw player
    ctx.fillStyle = '#9ff'; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
    // move player
    if (keys.ArrowUp) player.y -= 2.4;
    if (keys.ArrowDown) player.y += 2.4;
    if (keys.ArrowLeft) player.x -= 2.4;
    if (keys.ArrowRight) player.x += 2.4;
    player.x = Math.max(player.r, Math.min(w-player.r, player.x)); player.y = Math.max(player.r, Math.min(h-player.r, player.y));
    // pellet collision
    for (const p of pellets){ if (!p.got){ if (Math.hypot(player.x-p.x, player.y-p.y) < player.r + 6){ p.got=true; playBeep(760,0.04,0.04); } } }
    // ghost slowly moves toward player
    const ang = Math.atan2(player.y - ghost.y, player.x - ghost.x);
    ghost.x += Math.cos(ang) * 0.9;
    ghost.y += Math.sin(ang) * 0.9;
    // collision with ghost -> fail
    if (Math.hypot(player.x - ghost.x, player.y - ghost.y) < player.r + ghost.r - 2){
      document.removeEventListener('keydown', kd); document.removeEventListener('keyup', ku);
      finishActiveTask(false);
      return;
    }
    if (left === 0){
      document.removeEventListener('keydown', kd); document.removeEventListener('keyup', ku);
      finishActiveTask(true); return;
    }
    requestAnimationFrame(draw);
  }
  function kd(e){ keys[e.key]=true; }
  function ku(e){ keys[e.key]=false; }
  document.addEventListener('keydown', kd); document.addEventListener('keyup', ku);
  requestAnimationFrame(draw);
}

/* ---------- REPAIR WIRES TASK ---------- */
function initRepairTask(container){
  // simple reorder puzzle: connect left to right by matching colors
  const colors = ['#f55','#5f5','#55f','#ff8','#8ff'];
  const left = colors.slice().sort(()=>Math.random()-0.5);
  const right = colors.slice().sort(()=>Math.random()-0.5);
  container.innerHTML = `<div style="display:flex;gap:12px;align-items:center;justify-content:center">
    <div id="leftCol" style="display:flex;flex-direction:column;gap:8px"></div>
    <div id="midCol" style="width:40px;height:180px;display:flex;align-items:center;justify-content:center;color:var(--muted)">↔</div>
    <div id="rightCol" style="display:flex;flex-direction:column;gap:8px"></div>
  </div><div style="font-size:12px;color:var(--muted);margin-top:8px">Click left, then click matching right to connect. Connect all pairs.</div>`;
  const leftCol = container.querySelector('#leftCol');
  const rightCol = container.querySelector('#rightCol');
  left.forEach((c,i)=>{
    const el = document.createElement('div'); el.className='card clickable'; el.style.background=c; el.dataset.color=c; el.textContent=' ';
    el.style.height='34px'; leftCol.appendChild(el);
  });
  right.forEach((c,i)=>{
    const el = document.createElement('div'); el.className='card clickable'; el.style.background=c; el.dataset.color=c; el.textContent=' ';
    el.style.height='34px'; rightCol.appendChild(el);
  });
  let picked = null;
  let pairs = 0;
  container.querySelectorAll('#leftCol .card').forEach(el=>{
    el.addEventListener('click', ()=> {
      if (picked === el) { picked = null; el.style.outline=''; return; }
      if (picked && picked.closest('#leftCol')) { // switching
        picked.style.outline=''; picked = el; el.style.outline='3px solid #fff'; return;
      }
      picked = el; el.style.outline='3px solid #fff';
    });
  });
  container.querySelectorAll('#rightCol .card').forEach(el=>{
    el.addEventListener('click', ()=> {
      if (!picked) return;
      // check match
      if (picked.dataset.color === el.dataset.color){
        // mark connected
        picked.style.opacity='0.4'; el.style.opacity='0.4'; picked.style.pointerEvents='none'; el.style.pointerEvents='none';
        picked.style.outline=''; el.style.outline='';
        picked = null;
        pairs++;
        playBeep(900,0.04,0.05);
        if (pairs === colors.length) finishActiveTask(true);
      } else {
        // wrong: small panic
        increasePanic(6);
        playBeep(200,0.12,0.06,'sawtooth');
        if (picked) { picked.style.outline=''; picked=null; }
      }
    });
  });
}

/* ---------- JUMPSCARE ---------- */
let jumpscareHappened = false;
function triggerJumpscare(){
  if (jumpscareHappened) return;
  jumpscareHappened = true;
  // full red flash and face
  panicOverlay.classList.add('panic-red');
  // generate a scary face via text / svg
  jumpscareFace.textContent = '';
  // build simple creepy SVG face (procedural)
  const svg = `
    <svg viewBox="0 0 800 800" width="80%" height="80%" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#120002"/>
      <g transform="translate(400 380)">
        <ellipse rx="240" ry="320" fill="#000" stroke="#8b0000" stroke-width="8"/>
        <circle cx="-80" cy="-50" r="40" fill="#fff"/>
        <circle cx="90" cy="-40" r="40" fill="#fff"/>
        <rect x="-140" y="60" width="280" height="40" fill="#150000" rx="8"/>
        <path d="M -120 100 Q -60 180 0 120 Q 60 180 120 100" fill="#2b0000"/>
        <text x="-230" y="-220" fill="#ff7a7a" font-size="36" font-family="monospace">REMEMBER.</text>
      </g>
    </svg>`;
  jumpscareFace.innerHTML = svg;
  // show jumpscare overlay
  jumpscareEl.classList.add('show');
  jumpscareEl.classList.add('flashMe');
  jumpscareFace.classList.add('flash');
  // loud burst sound
  ensureAudio();
  const g = audioCtx.createGain(); g.gain.value = 0.001; g.connect(audioCtx.destination);
  const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value=80;
  o.connect(g); o.start();
  // ramp up quickly and noise burst
  g.gain.linearRampToValueAtTime(0.9, audioCtx.currentTime + 0.06);
  setTimeout(()=> {
    // white noise burst
    const bufferSize = audioCtx.sampleRate * 0.2;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1)*Math.exp(-i/bufferSize*3);
    const noise = audioCtx.createBufferSource(); noise.buffer = buffer;
    const ng = audioCtx.createGain(); ng.gain.value = 0.6; ng.connect(audioCtx.destination);
    noise.connect(ng); noise.start();
    // stop oscillator
    g.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
    o.stop(audioCtx.currentTime + 0.1);
    // show red full
    panicOverlay.style.transition = 'background 0.06s linear';
    panicOverlay.style.background = 'rgba(180,0,0,0.9)';
  }, 90);

  // after short time, end game with failure
  setTimeout(()=> {
    endGame(false, 'Jumpscare — you were caught.');
  }, 1600);
}

/* ---------- ENDGAME ---------- */
function endGame(win, reason){
  // stop breathing timers
  if (breathEventTimer) { clearTimeout(breathEventTimer); breathEventTimer=null; }
  if (taskTimerInterval) { clearInterval(taskTimerInterval); taskTimerInterval=null; }
  if (gameTimerInterval) { clearInterval(gameTimerInterval); gameTimerInterval=null; }

  // display message
  if (win){
    alert('You survived and memory returns...\n' + (reason || 'Victory.'));
    // could show credits / memory reveal
    location.reload();
  } else {
    alert('You failed: ' + (reason || 'Caught.'));
    location.reload();
  }
}

/* ---------- SCHEDULING / INIT ---------- */
function init(){
  updatePillsUI();
  updatePanicUI();
  updateProgressUI();
  startGameTimer();
  startBreathingLoop();
  scheduleBreathEvent();
  appendScreenText('You wake up. The room is quiet. Open the PC to begin.');

  // simple pill clicks: clicking visual pill acts as taking pill
  pillsContainer.querySelectorAll('.pill').forEach(el=>{
    el.addEventListener('click', ()=> {
      // allow click only if pill not empty
      if (el.classList.contains('empty')) { appendScreenText('No pill there.'); return; }
      // take pill
      if (pills <= 0) return;
      pills--;
      updatePillsUI();
      decreasePanic(18);
      appendScreenText('You took a pill (visual).');
      playBeep(1200,0.08,0.06,'sine');
      scheduleBreathEvent();
    });
  });
}

// call init
init();

/* ---------- small UX helpers (safety) ---------- */
function scheduleBreathEvent(){ scheduleBreathEventImpl(); } // alias to function defined later

// we defined scheduleBreathEvent earlier; but JS function hoisting requires adjusting; to keep code tidy, wrap scheduling function here:
function scheduleBreathEventImpl(){
  if (breathEventTimer) { clearTimeout(breathEventTimer); breathEventTimer = null; }
  const min = 1200;
  const max = 8000;
  const interval = Math.round(max - (panic/100) * (max - min));
  const jitter = Math.floor(Math.random() * 800) - 400;
  const next = Math.max(min, interval + jitter);
  breathEventTimer = setTimeout(()=> { triggerBreath(); scheduleBreathEventImpl(); }, next);
}

/* Utility small function to rewire scheduleBreathEvent variable to correct implementation */
scheduleBreathEvent = scheduleBreathEventImpl;

/* Keep UI responsive: click outside overlay closes choices if no active task */
overlay.addEventListener('click', (e)=>{
  if (e.target === overlay && !activeTask) closeOverlay();
});

/* Prevent accidental text selection while playing */
document.addEventListener('selectstart', e => { if (overlayOpen) e.preventDefault(); });

/* END OF SCRIPT */
</script>
</body>
</html>
